<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>测试 | Reflux-Sharing</title><meta name="author" content="Reflux"><meta name="copyright" content="Reflux"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、数组1、二分查找 防止left+right溢出。  int middle &#x3D; left + ((right - left) &gt;&gt; 1); 123456789101112131415161718192021222324252627282930313233343536373839404142#### 2、移除元素双指针1. 左指针等于val，右指针无脑覆盖并左移，直到左指针不等于val">
<meta property="og:type" content="article">
<meta property="og:title" content="测试">
<meta property="og:url" content="https://blog.reflux-sharing.top/posts/9daba997.html">
<meta property="og:site_name" content="Reflux-Sharing">
<meta property="og:description" content="一、数组1、二分查找 防止left+right溢出。  int middle &#x3D; left + ((right - left) &gt;&gt; 1); 123456789101112131415161718192021222324252627282930313233343536373839404142#### 2、移除元素双指针1. 左指针等于val，右指针无脑覆盖并左移，直到左指针不等于val">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-11-08T06:46:37.000Z">
<meta property="article:modified_time" content="2023-11-08T08:31:30.033Z">
<meta property="article:author" content="Reflux">
<meta property="article:tag" content="node.js">
<meta property="article:tag" content="hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.reflux-sharing.top/posts/9daba997.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"VIV9BBZ1HS","apiKey":"593bec3059f32f14fecfe3ac71a4d2bc","indexName":"hexo_blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '测试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-08 16:31:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Reflux-Sharing" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://reflux-project.oss-cn-beijing.aliyuncs.com/butterfly-blog/Drink_103663830_5472279_%E3%81%BE%E3%81%94%E3%81%A4%E3%81%8D.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-share-alt-square"></i><span> 分享</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Reflux-Sharing"><span class="site-name">Reflux-Sharing</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/share/"><i class="fa-fw fa fa-share-alt-square"></i><span> 分享</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-08T06:46:37.000Z" title="发表于 2023-11-08 14:46:37">2023-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-08T08:31:30.033Z" title="更新于 2023-11-08 16:31:30">2023-11-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="测试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><h4 id="1、二分查找"><a href="#1、二分查找" class="headerlink" title="1、二分查找"></a>1、二分查找</h4><ol>
<li><p>防止left+right溢出。</p>
</li>
<li><pre><code class="cpp">int middle = left + ((right - left) &gt;&gt; 1);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2、移除元素</span><br><span class="line"></span><br><span class="line">双指针</span><br><span class="line"></span><br><span class="line">1. 左指针等于val，右指针无脑覆盖并左移，直到左指针不等于val才可以右移。</span><br><span class="line">2. 优化，右指针不无脑覆盖，只在不等于val时覆盖。</span><br><span class="line"></span><br><span class="line">快慢指针</span><br><span class="line"></span><br><span class="line">1. 移动fast，当fast不等于val，用fast覆盖slow，slow++。</span><br><span class="line"></span><br><span class="line">#### 3、有序数组的平方</span><br><span class="line"></span><br><span class="line">1. 类似合并排序，用双指针。</span><br><span class="line"></span><br><span class="line">#### 4、长度最小的子数组</span><br><span class="line"></span><br><span class="line">1. 不同于：子数组和最大，本题的和是一定的，只求最短子数组，不用动态规划</span><br><span class="line">2. 用滑动窗口</span><br><span class="line"></span><br><span class="line">#### 5、螺旋矩阵Ⅱ</span><br><span class="line"></span><br><span class="line">1. 模拟时循环区间的注意。</span><br><span class="line">2. 左闭右开，并且每次画圈，四个循环迭代次数是相同的</span><br><span class="line">3. loop次数等于n/2，为奇数时单独处理中心。</span><br><span class="line"></span><br><span class="line">#### 6、[旋转图像](https://leetcode.cn/problems/rotate-image/)</span><br><span class="line"></span><br><span class="line">创维9.15笔试最后一题，没写出来，用了最傻逼的办法，我测</span><br><span class="line"></span><br><span class="line">法一：使用辅助数组</span><br><span class="line"></span><br><span class="line">![ccw-01-07.001.png](测试.assets/202310292200945.png)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">        matrix_new[j][n - i - 1] = matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>法二：不使用辅助数组</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200946.png" alt="ccw-01-07.003.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">        matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">        matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">        matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">        matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>旋转的不变量：</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200947.png" alt="image-20230916110057332"></p>
<p>法三：翻转代替旋转</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200948.png" alt="image-20230916103909197"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="comment">//上下交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                swap(i,j,n-i-<span class="number">1</span>,j,matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//my_print(n,matrix);</span></span><br><span class="line">        <span class="comment">//对角线交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                swap(i,j,j,i,matrix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//my_print(n,matrix);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        matrix[i][j]^=matrix[x][y];</span><br><span class="line">        matrix[x][y]^=matrix[i][j];</span><br><span class="line">        matrix[i][j]^=matrix[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_print</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>[][]matrix)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                System.out.print(matrix[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><h4 id="定义的模板："><a href="#定义的模板：" class="headerlink" title="定义的模板："></a>定义的模板：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-反转链表系列"><a href="#1-反转链表系列" class="headerlink" title="1.反转链表系列"></a>1.反转链表系列</h4><h5 id="1、反转链表"><a href="#1、反转链表" class="headerlink" title="1、反转链表"></a>1、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h5><ol>
<li>用tmp保存curr.next</li>
<li>pre初始值为null，相当于虚头节点，不需要处理pre的next，直接移动pre即可</li>
<li>while循环内只看curr是否为null</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkNode pre=<span class="literal">null</span>,tmp=<span class="literal">null</span>,curr=head;</span><br><span class="line"><span class="keyword">while</span> (curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">	tmp=curr.next;</span><br><span class="line">    curr.next=pre;</span><br><span class="line">    pre=curr;</span><br><span class="line">    curr=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200949.png" alt="image-20230828102202398"></p>
<h5 id="2、反转链表-II"><a href="#2、反转链表-II" class="headerlink" title="2、反转链表 II"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a></h5><p>这题和上面的不同之处就在于局部反转</p>
<p>法一：头插法</p>
<p>细节很多</p>
<ol>
<li><p>pre节点不需要动</p>
</li>
<li><p>每次反转，是把nextNode反转到局部链表的头部！而不是把nextNode和curr两两反转</p>
<p>所以是：<code>tmp.next = pre.next;</code>，而不是<code>tmp.next = curr;</code>，和第一题区别</p>
<p>而当nextNode移动到最前面，curr在链表的位置便自动向后移动一步，所以不需要额外移动curr</p>
</li>
<li><p>每次反转，要把curr节点移到后面，所以是<code>curr.next = tmp.next;</code></p>
</li>
</ol>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200950.png" alt="image-20230828102240793"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;left-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            pre = pre.next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> pre.next,tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            tmp = curr.next;<span class="comment">//记录curr的nextNode</span></span><br><span class="line">            curr.next = tmp.next;<span class="comment">//先记录next的next</span></span><br><span class="line">            tmp.next = pre.next;<span class="comment">//再修改next的next，注意这里不能指向curr</span></span><br><span class="line">            pre.next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：穿针引线</p>
<p>就是利用反转链表Ⅰ的思路，先反转局部</p>
<p>然后把 pre的 next 指针指向反转以后的链表头节点，把反转以后的链表的尾节点的next 指针指向curr。</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200951.png" alt="image-20230828102647535"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//必须要用dummy！否则单个节点pre.next为null，curr = rightNdoe.next就不存在了！</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;left-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            pre = pre.next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightNdoe</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            rightNdoe = rightNdoe.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> rightNdoe.next;</span><br><span class="line">        rightNdoe.next = <span class="literal">null</span>;<span class="comment">//局部链表反转终止条件</span></span><br><span class="line">        reverseList(leftNode);<span class="comment">//反转后leftNode为局部链表的尾部</span></span><br><span class="line">        pre.next = rightNdoe;</span><br><span class="line">        leftNode.next = curr;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        ListNode pre=<span class="literal">null</span>,curr=head,tmp=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            tmp = curr.next;</span><br><span class="line">            curr.next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、两两交换链表中的节点"><a href="#3、两两交换链表中的节点" class="headerlink" title="3、两两交换链表中的节点"></a>3、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h5><p>使用的是第二题第二种思路的简化版、10.13、8min</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span> (-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        ListNode tmp;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span>&amp;&amp;curr.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            tmp = curr.next;</span><br><span class="line">            curr.next = tmp.next;<span class="comment">//修改局部反转后链表的尾节点指向</span></span><br><span class="line">            tmp.next = curr;<span class="comment">//局部反转</span></span><br><span class="line">            pre.next = tmp;<span class="comment">//pre指向反转后局部链表的头节点</span></span><br><span class="line">            pre = curr;<span class="comment">//移动，进行下一步反转</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、K-个一组翻转链表"><a href="#4、K-个一组翻转链表" class="headerlink" title="4、K 个一组翻转链表"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></h5><p>这个使用第二题的第一种思路：</p>
<ul>
<li>只有一个节点不需要反转，所以<code>j</code>从1开始</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span> (-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> len/k;<span class="comment">//向下取整，最后不足k个不反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy,tmp;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 只有一个节点不需要反转，所以j从1开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;k;j++)&#123;</span><br><span class="line">                tmp = curr.next;<span class="comment">//至少有两个节点才能进循环，所以curr.next一定存在</span></span><br><span class="line">                curr.next = tmp.next;<span class="comment">//向后移curr的预处理</span></span><br><span class="line">                <span class="comment">// 把tmp移到局部链表的头</span></span><br><span class="line">                tmp.next = pre.next;</span><br><span class="line">                pre.next = tmp;</span><br><span class="line">                <span class="comment">// 移动tmp完毕，curr的位置就会自动向后移动一位，不需要额外移动</span></span><br><span class="line">            &#125;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他妈的，链表反转算是会了吧！一定要会阿🤢！</p>
<h4 id="2-双指针系列："><a href="#2-双指针系列：" class="headerlink" title="2.双指针系列："></a>2.双指针系列：</h4><h5 id="1-旋转链表"><a href="#1-旋转链表" class="headerlink" title="1.旋转链表"></a>1.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">旋转链表</a></h5><p>要求：将链表每个节点向右移动 k 个位置。</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200952.png" alt="image-20230828115531419"></p>
<p>法一：链表反转（遍历两遍）</p>
<p>将整个链表反转变成{5,4,3,2,1}，然后再将前K和N-K两个部分分别反转。</p>
<p>也就是分别变成了{4,5}和{1,2,3},这样就轻松解决了。</p>
<p>法二：双指针（遍历一遍）</p>
<p>先用双指针策略找到倒数K的位置，也就是{1,2,3]和{4,5}两个序列，之后再将两个链表拼接成{4,5,1,2,3}就行了。</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200953.png" alt="image-20230828120611680"></p>
<h5 id="2-删除链表倒数第N个节点"><a href="#2-删除链表倒数第N个节点" class="headerlink" title="2.删除链表倒数第N个节点"></a>2.删除链表倒数第N个节点</h5><p>快慢指针，快指针先走N步，然后快慢同时走，当快指针为null时，慢指针到达应删节点的pre。</p>
<h5 id="3-链表相交"><a href="#3-链表相交" class="headerlink" title="3.链表相交"></a>3.链表相交</h5><p>双指针法</p>
<p>先求链表长度，然后移动较长head使两链表剩下的部分等长，再同时移动两head直到两头相等就找到交点了</p>
<h5 id="4-环形链表系列"><a href="#4-环形链表系列" class="headerlink" title="4.环形链表系列"></a>4.环形链表系列</h5><p>快慢指针，快走两步，慢走一步，两者遇上时（有环）：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></p>
<p>然后慢指针从头和快指针一步一步走，直到二者相等即是环形入口：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a></p>
<p>环形链表的应用：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">寻找重复数</a></p>
<p>如何将数组扩展成链表问题？（不会就先构造链表吧😂）</p>
<ul>
<li>将nums[index]看作是链表的节点</li>
<li>将index看作是节点中的next指针</li>
</ul>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200954.png" alt="image-20230828112027780"></p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200955.png" alt="image-20230828112039417"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">( <span class="type">int</span>[ ] nums)</span> &#123;<span class="comment">//如 nums = [1,3,4,2,2]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    slow = nums[slow];<span class="comment">//初始节点为1</span></span><br><span class="line">    fast = nums[nums[fast]];<span class="comment">//初始节点为nums[1]=3</span></span><br><span class="line">    <span class="comment">// 找环，题目说一定有且只有一个重复数</span></span><br><span class="line">    <span class="keyword">while</span> ( slow != fast) &#123;</span><br><span class="line">         <span class="comment">// sLow = sLow.next;</span></span><br><span class="line">        slow = nums [slow];</span><br><span class="line">        <span class="comment">// fast = fast.next.next;</span></span><br><span class="line">        fast = nums [nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找重复数入口：sLow回到初始位置，fast在相遇的位置</span></span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[ slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-回文链表"><a href="#6-回文链表" class="headerlink" title="6.回文链表"></a>6.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h5><p>法一：</p>
<p>涉及：快慢指针分割链表（找中点），反转链表，链表的比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            fast = fast.next.next;<span class="comment">//快走两步</span></span><br><span class="line">            slow = slow.next;<span class="comment">//慢走一步</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;<span class="comment">//别忘了分割链表！</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">link1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">link2</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="comment">//print(link1);</span></span><br><span class="line">        <span class="comment">//print(link2);</span></span><br><span class="line">        link2 = reverse(link2);</span><br><span class="line">        <span class="comment">//print(link2);</span></span><br><span class="line">        <span class="comment">//分割链表后，两链表要么长度相等，要么后面比前面多一个节点，所以while可以判断短那条</span></span><br><span class="line">        <span class="keyword">while</span>(link1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//不能直接比较link1和link2，因为它们是同一链表上不同节点！只是值相等而已</span></span><br><span class="line">            <span class="keyword">if</span>(link1.val==link2.val)&#123;</span><br><span class="line">                link1 = link1.next;</span><br><span class="line">                link2 = link2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        ListNode pre=<span class="literal">null</span>,curr=head,tmp;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            tmp = curr.next;</span><br><span class="line">            curr.next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = tmp;<span class="comment">//别curr = curr.next，因为curr.next已经变成pre了！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.print(tmp.val);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：把链表节点丢到<code>ArrayList</code>，然后就可以双指针了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(curr);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i).val!=list.get(j).val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度分析：都是O(n)，但下面这个更慢，不知道为啥。</p>
<p>空间复杂度：下面O(n)，上面O(1)</p>
<h5 id="7-删除链表重复元素"><a href="#7-删除链表重复元素" class="headerlink" title="7.删除链表重复元素"></a>7.删除链表重复元素</h5><p>删除到只剩一个：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">删除排序链表中的重复元素</a></p>
<p>1、快慢指针，慢指针和快指针相同，删快指针所在节点，只有快指针移动，不相同，两指针同时移动一步</p>
<p>2、用set存出现过的元素，然后删重复的即可</p>
<p>把重复元素全删除：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">删除排序链表中的重复元素 II</a></p>
<p>和上题的区别是：</p>
<ul>
<li>头节点可能都被删除，所以一定要用dummy</li>
<li><code>curr.next.next</code>可能为空，而我们需要获取它的值，所以需要对它进行判空处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head ) ;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> dummy ;</span><br><span class="line">    <span class="keyword">while</span>(curr.next != <span class="literal">null</span> &amp;&amp; curr.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//如果存在重复的节点</span></span><br><span class="line">        <span class="keyword">if</span>( curr.next.val == curr.next.next.val)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmpVal</span> <span class="operator">=</span> curr.next.val;</span><br><span class="line">            <span class="comment">//持续的删除(将等于tmpVaL的节点都删除，包括自己)</span></span><br><span class="line">            <span class="keyword">while</span>(curr.next != <span class="literal">null</span> &amp;&amp; curr.next.val == tmpVal)&#123;</span><br><span class="line">                <span class="comment">//此处curr相当于pre，curr.next就是要删除的当前节点</span></span><br><span class="line">                curr.next = curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curr = curr .next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy .next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-链表排序"><a href="#3-链表排序" class="headerlink" title="3.链表排序"></a>3.链表排序</h4><h5 id="5-重排链表"><a href="#5-重排链表" class="headerlink" title="5.重排链表"></a>5.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">重排链表</a></h5><p>使用双端队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Deque&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//记一下双端队列的名字Deque！</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;<span class="comment">//头节点不用入栈，避免重复</span></span><br><span class="line">        <span class="keyword">while</span>(curr.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(curr.next);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//偶数队列尾出栈，因为队列先进先出，所以链表尾在队列尾</span></span><br><span class="line">                curr.next = queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = queue.poll();<span class="comment">//奇数队列头出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.next = <span class="literal">null</span>;<span class="comment">//别忘了处理最后！否则成环！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-排序链表"><a href="#8-排序链表" class="headerlink" title="8.排序链表(!)"></a>8.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">排序链表</a>(!)</h5><p>要求O(1)空间复杂度（最难），O(nlogn)时间复杂度，只能修改next，不能修改val</p>
<p>下面是没那么多要求的做法，最方便！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list,(a,b)-&gt; a.val-b.val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            list.get(i).next = list.get(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(list.size()-<span class="number">1</span>).next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一版：</span></span><br><span class="line">Collections.sort(list,(ListNode a,ListNode b)-&gt;&#123;<span class="keyword">return</span> a.val-b.val;&#125;);</span><br><span class="line"><span class="comment">//返回值和参数类型都可以简化，第二版如下：</span></span><br><span class="line">Collections.sort(list,(a,b)-&gt; a.val-b.val);</span><br><span class="line"><span class="comment">//idea直接把我的全换了😂，第三版如下：</span></span><br><span class="line">list.sort(Comparator.comparingInt((ListNode a) -&gt; a.val));</span><br><span class="line"><span class="comment">//或者最原始的使用内部类：</span></span><br><span class="line">list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ListNode o1, ListNode o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>链表最适合的是归并排序！最容易想到的实现方式是自顶向下的递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sortList(head, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="comment">//当链表为空或者链表只包含 1 个节点时，递归中止</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.next == tail) &#123;</span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span> (fast != tail) &#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> slow;</span><br><span class="line">        <span class="comment">//对两个子链表排序</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">list1</span> <span class="operator">=</span> sortList(head, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">list2</span> <span class="operator">=</span> sortList(mid, tail);</span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sorted</span> <span class="operator">=</span> merge(list1, list2);</span><br><span class="line">        <span class="keyword">return</span> sorted;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 使用非递归来合并</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummyHead, temp1 = head1, temp2 = head2;</span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">null</span> &amp;&amp; temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp1.val &lt;= temp2.val) &#123;</span><br><span class="line">                temp.next = temp1;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = temp2;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用递归来合并</span></span><br><span class="line">    ListNode <span class="title function_">mergeSortedList</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!head1 || !head2) <span class="keyword">return</span> head1 ? head1 : head2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt; head2.val) &#123;</span><br><span class="line">            head1.next = mergeSortedList(head1.next, head2);</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head2.next = mergeSortedList(head1, head2.next);</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(log⁡n)。如果要达到 O(1) 的空间复杂度，则需要使用自底向上的实现方式。这个…看之前学校算法课吧，当年我搞得很懂。</p>
<p>下面是力扣上的解释，也不是不能看懂，但是背起来就很烦了，滚😂</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200956.png" alt="image-20230826232704906"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先求得链表的长度 length</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="comment">//用 subLength 表示每次需要排序的子链表的长度，初始时 subLength 为1</span></span><br><span class="line">        <span class="comment">//分步为1两两合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">subLength</span> <span class="operator">=</span> <span class="number">1</span>; subLength &lt; length; subLength &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead, curr = dummyHead.next;</span><br><span class="line">            <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> curr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> curr.next;</span><br><span class="line">                curr.next = <span class="literal">null</span>;</span><br><span class="line">                curr = head2;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; subLength &amp;&amp; curr != <span class="literal">null</span> &amp;&amp; curr.next != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">                    next = curr.next;</span><br><span class="line">                    curr.next = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">merged</span> <span class="operator">=</span> merge(head1, head2);</span><br><span class="line">                prev.next = merged;</span><br><span class="line">                <span class="keyword">while</span> (prev.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                    prev = prev.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 合并和之前一样</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">		<span class="comment">//略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三、散列表"><a href="#三、散列表" class="headerlink" title="三、散列表"></a>三、散列表</h2><h4 id="1-有效的字母异词位"><a href="#1-有效的字母异词位" class="headerlink" title="1.有效的字母异词位"></a>1.有效的字母异词位</h4><ol>
<li><p>字符有重复，要两边重复次数相同</p>
</li>
<li><p>java没有unorderset，只能用map将就</p>
</li>
<li><p>map的get得到的value是右值，没有地址，不能自增，也就是进行++操作，只能进行+1操作</p>
</li>
<li><pre><code class="java">map.getOrDefault(c,0)+1
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.两个数组的交集</span><br><span class="line"></span><br><span class="line">1. 输出结果每个元素唯一，用set</span><br><span class="line"></span><br><span class="line">2. set怎么转数组</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   set2.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="3-快乐数"><a href="#3-快乐数" class="headerlink" title="3.快乐数"></a>3.快乐数</h4><ol>
<li>对每个位置上的数字求平方，再求和，会导致无限循环，这意味着和重复出现！用set判断循环终止</li>
</ol>
<h4 id="4-两数之和"><a href="#4-两数之和" class="headerlink" title="4.两数之和"></a>4.两数之和</h4><ol>
<li><p>用map的value记录下标</p>
</li>
<li><p>在return的时候直接创建数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> []&#123;i,x.get(target-nums[i])&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-四数相加-II"><a href="#5-四数相加-II" class="headerlink" title="5.四数相加 II"></a>5.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">四数相加 II</a></h4><p>思路：</p>
<ol>
<li><p>给定四个数组，先遍历前两个求和，再遍历后两个，转成两数之和求解</p>
</li>
<li><p>用map.getOrDefault，在没找到另一半时返回默认value，0。</p>
</li>
<li><p>如果找得到，那么res加的就是前面所有求和等于（0-i-j）的情况，不需要对value–。</p>
<p>除非你想一个一个加，多此一举。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res+=map.getOrDefault(<span class="number">0</span>-i-j,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        HashMap &lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums2)&#123;</span><br><span class="line">                <span class="comment">//getOrDefault获取key对应value，找不到给默认值，也就是第二个参数0</span></span><br><span class="line">                <span class="comment">//有-2+1和1+(-2)的可能</span></span><br><span class="line">                map.put(i+j,map.getOrDefault(i+j,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums4)&#123;</span><br><span class="line">                res+=map.getOrDefault(<span class="number">0</span>-i-j,<span class="number">0</span>);<span class="comment">//看看map有没有另一半，没有加0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-三数之和-四数之和"><a href="#6-三数之和-四数之和" class="headerlink" title="6.三数之和&amp;四数之和"></a>6.<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">三数之和</a>&amp;<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">四数之和</a></h4><ol>
<li><p>可以转化为两数之和求解（去重条件不好记忆，不推荐）</p>
<ol>
<li><p>用hash的话跟双指针的区别在于，最后一个左指针的去重，是在if条件里，而不是在循环开始</p>
<p>并且是和j+1比。</p>
</li>
<li><p>原因是（比如三数之和），0 0 0</p>
<p>第一个左指针在第一个0，</p>
<p>刚开始，不管哪种方案，第二个左指针都在第二个0，此时set不含-first-second，需要插入。</p>
<p>如果第二个左指针的去重在循环开始位置，并且和j-1比较，那么第二个左指针会从第二个0直接跳出循环，不会再判断set是否含有third。</p>
<p>而如果第二个左指针在if条件里，并且和j+1比较，那么第二个左指针会从第二个0找到最后一个0，此时set包含third，判断成功。</p>
<p>也就是用set需要第二个左指针多判断一次。（很复杂吧。）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(set.contains(second))&#123;</span><br><span class="line">	res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(first,second,third)));</span><br><span class="line">	<span class="keyword">while</span>(j&lt;nums.length-<span class="number">1</span>&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最好用双指针求解。</p>
</li>
<li><p>模板如下</p>
<ol>
<li><p>先排序</p>
</li>
<li><p>可优化的地方：first+右边界几个数如果小于target，那就不用继续了，因为加上最大的几个数都达不到target。</p>
</li>
<li><p>去重的注意事项：比如111222333</p>
<p>用<code>if(first&gt;0&amp;&amp;nums[first]==nums[first-1])continue;</code></p>
<p>用<code>j-1</code>，那么当前在第二个2（不跑），会找到第一个3。</p>
<p>如果比较first+1，那就是假如当前在最后一个1，会找得是最后一个2。</p>
<p>那么second就会从first的下一个元素开始，也就是3，无法和first取相同元素</p>
<p>记住，三数之和组内元素是可以重复的，也就是first不可以重复，而second可以和first一样。</p>
<p>左指针要比较first-1。</p>
</li>
<li><p>而后面的元素也是一样的去重，直到最后一个元素（也就是右指针），才开始while移动右指针。</p>
</li>
<li><p><strong>右指针的初始化放在倒数第二个左指针循环之前</strong>（避免每次左指针移动重复初始化右指针）</p>
<p>更深的原因是，排序后，a+b+c&#x3D;0，然后b右移，而c不用回到n-1，因为b变大了，比当前c大的数都不用再试了。</p>
</li>
<li><p>最后加法需要看数据量级，最好将和强制转化为long，否则小心越界。</p>
</li>
</ol>
</li>
</ol>
<p>三数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[first]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span>&amp;&amp;nums[first]==nums[first-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> third=n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(second&gt;first+<span class="number">1</span>&amp;&amp;nums[second]==nums[second-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(second&lt;third&amp;&amp;nums[first]+nums[second]+nums[third]&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(second==third)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[first]+nums[second]+nums[third]==<span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(nums[first],nums[second],nums[third])));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span>&amp;&amp;nums[first]==nums[first-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(second&gt;first+<span class="number">1</span>&amp;&amp;nums[second]==nums[second-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> last=n-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> third=second+<span class="number">1</span>;third&lt;n;third++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(third&gt;second+<span class="number">1</span>&amp;&amp;nums[third]==nums[third-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">while</span>(third&lt;last</span><br><span class="line">                          &amp;&amp;(<span class="type">long</span>)nums[first]+nums[second]+nums[third]+nums[last]&gt;target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        last--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(third==last)<span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>( (<span class="type">long</span>)</span><br><span class="line">                       nums[first]+nums[second]+nums[third]+nums[last]==target)&#123;</span><br><span class="line">                        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(</span><br><span class="line">                            nums[first],nums[second],nums[third],nums[last]</span><br><span class="line">                        )));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><h4 id="1、反转字符串"><a href="#1、反转字符串" class="headerlink" title="1、反转字符串"></a>1、反转字符串</h4><ol>
<li><p>解法：双指针</p>
</li>
<li><p>不用额外空间的交换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2、反转字符串-II"><a href="#2、反转字符串-II" class="headerlink" title="2、反转字符串 II"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">反转字符串 II</a></h4><p>固定规律分段处理字符串：</p>
<ol>
<li><p>需要按固定规律一段一段处理字符串时，用for循环！</p>
</li>
<li><p>拿while循环很难判断终止条件</p>
</li>
<li><p>反转字符串，要先把字符串变成StringBuffer或者char数组先。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> []c = s.toCharArray()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">return</span> str.toString();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=s.length();</span><br><span class="line">    <span class="type">char</span> [] c = s.toCharArray(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>*k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+k&lt;=n)reverse(c,i,i+k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> reverse(c,i,n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、替换空格"><a href="#3、替换空格" class="headerlink" title="3、替换空格"></a>3、替换空格</h4><p>数组填充类题目，本题是把空格替换为<code>%20</code>：</p>
<p>方法一：</p>
<ul>
<li>开辟一个新字符串，遇到其他直接复制，遇到空格连接上要替换的字符即可（遍历一次）</li>
</ul>
<p>方法二：</p>
<ul>
<li><p>双指针（遍历两次，时间换空间）</p>
</li>
<li><p>先循环一次，遇到空格，append一次，<strong>将数组扩容到合适的位置</strong></p>
</li>
<li><p><strong>第二次循环从后往前</strong>扫描，左指针在扩容前的末尾，右指针在扩容后字符串的末尾。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        x.append(<span class="string">&quot;  &quot;</span>);<span class="comment">//扩容用string或者StringBuffer都可以，一定要扩容，不然越界！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x.length()==<span class="number">0</span>)<span class="keyword">return</span> s;</span><br><span class="line"><span class="type">int</span> i=s.length()-<span class="number">1</span>;</span><br><span class="line">s+=x.toString();<span class="comment">//扩容到合适的位置</span></span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        StringBuilder x=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                x.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x.length()==<span class="number">0</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> i=s.length()-<span class="number">1</span>;</span><br><span class="line">        s+=x.toString();</span><br><span class="line">        <span class="type">char</span> [] c = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> j=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                c[j--]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                c[j--]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                c[j]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                c[j]=c[i];</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、翻转字符串里的单词"><a href="#4、翻转字符串里的单词" class="headerlink" title="4、翻转字符串里的单词"></a>4、翻转字符串里的单词</h4><ol>
<li><p>方法一：双指针从后往前扫描，用substring切割单词，拼到新串上，空间开销为O（n）</p>
</li>
<li><p>方法二：先快慢指针移除空格</p>
<p>这种局部反转的题，可以考虑先全局反转，再从前往后局部反转，如果所用的语言string是可变长的，那么空间开销为O（1）</p>
</li>
</ol>
<h4 id="5、动态口令"><a href="#5、动态口令" class="headerlink" title="5、动态口令"></a>5、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">动态口令</a></h4><p>左旋转字符串：</p>
<ol>
<li><p>方法一：双指针，从前往后，慢慢把前n个字符串倒腾到最后，空间为O（1）</p>
</li>
<li><p>方法二：先全局反转，再反转前len-n个，最后反转最后n个即可。空间为O（1）</p>
</li>
<li><p>方法三：创建新串，先拼接上n到len，再拼接上0到n上的字符串，空间为O（n）</p>
</li>
<li><p>拼接可以用以下代码，用取余简化代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;n+s.length();i++)&#123;</span><br><span class="line">	<span class="comment">//String为不可变对象,每轮都要创建新字符串</span></span><br><span class="line">	<span class="comment">//res=c</span></span><br><span class="line">	<span class="comment">//res=cd</span></span><br><span class="line">	<span class="comment">//res=cde</span></span><br><span class="line">	str+=s.charAt(i%s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上要注意，创建新串不要用string，用char[]或者stringbuilder。</p>
<p>因为string每次修改，都要创建新的对象，十分浪费时间和空间</p>
</li>
</ol>
<p>完整代码1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span> []c = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;n+s.length();i++)&#123;</span><br><span class="line">            c[k++]=s.charAt(i%s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码2：效率最高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dynamicPassword</span><span class="params">(String password, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//这不就是轮转数组吗？</span></span><br><span class="line">        <span class="type">char</span>[] c = password.toCharArray();</span><br><span class="line">        reverse(c,<span class="number">0</span>,target-<span class="number">1</span>);</span><br><span class="line">        reverse(c,target,password.length()-<span class="number">1</span>);</span><br><span class="line">        reverse(c,<span class="number">0</span>,password.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] s,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            s[i]^=s[j];</span><br><span class="line">            s[j]^=s[i];</span><br><span class="line">            s[i]^=s[j];</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP算法初学习："><a href="#KMP算法初学习：" class="headerlink" title="KMP算法初学习："></a>KMP算法初学习：</h4><ol>
<li><p>KMP算法负责解决查询子串的问题，原理是记录之前已匹配的信息避免从头开始匹配</p>
</li>
<li><p>文本串，模式串的定义：要在文本串中找是否含有模式串。</p>
</li>
<li><p>前缀表：记录模式串中从0到i（包括），有多大长度的相同前后缀</p>
<ol>
<li>前缀指的是串中以第一个字符开头的连续子串（不包含最后一个字符）</li>
<li>后缀指的是串中以最后一个字符结尾的连续子串（不包含第一个字符）</li>
<li>前缀和后缀长度是变化的。</li>
</ol>
</li>
<li><p>如何计算前缀表：</p>
<ol>
<li><p>比如aabaaf</p>
</li>
<li><p>前缀为a，aa，aab，aaba，aabaa，</p>
</li>
<li><p>后缀为f，af，aaf，baaf，abaaf，</p>
</li>
<li><p>最长相等前后缀（前缀从前往后，后缀从后往前，二者要完全相等）</p>
<p>a，0，前缀后缀为空</p>
<p>aa，1，前缀为a，后缀为a</p>
<p>aab，0，前缀为a、aa，后缀为b或者ab</p>
<p>aaba，1，前缀为a、aa、aab，后缀为a、ab，aba，最长相等前后缀为1</p>
<p>aabaa，2</p>
<p>aabaaf，0</p>
</li>
<li><p>用一个next数组记录前缀表</p>
</li>
</ol>
</li>
<li><p>如何利用前缀表去进行匹配：</p>
<ol>
<li><p>aabaaf和aab aabaaf a两个串</p>
</li>
<li><p>前缀表为：a a b a a f</p>
<p>​				   0 1 0 1 2 0</p>
</li>
<li><p>j表示模式串，i表示文本串</p>
</li>
</ol>
</li>
<li><p>next数组求解模板</p>
<ol>
<li><p>j是前缀末尾的位置，i是后缀末尾的位置</p>
</li>
<li><p>把 [0-j] 的前缀看成是模式串，把 [1-i] 的后缀看成是文本串,文本串每次移动一位</p>
</li>
<li><pre><code class="java">next[0]=0;//只有一个字符，最长相同前后缀为0
int j=0;
for(int i=1;i&lt;len;i++)&#123;//i从1开始，才能比较模式串本身
    while(j&gt;0&amp;&amp;s[i]!=s[j])//如果j回退到0，那就到底了，不用继续回退
    &#123;   //用while的原因，让j回退到上一个匹配（s[i]==s[j]）的点
        //只回退一次，可能next[j-1]还在s[i]!=s[j]的点
        //不用while，直接回退到0，那就和不用KMP，模式串无脑从头匹配一样了
        j=next[j-1];
    &#125;
    if(s[j]==s[i])&#123;
        j++; //更新从0到i最长相等前后缀的长度
    &#125;
    next[i]=j;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   4. 匹配到不正确的地方，除去不相等之处，模式串的子串跟文本串的子串相等</span><br><span class="line"></span><br><span class="line">      aabaa **f** 和aab aa**b** aaf a，</span><br><span class="line"></span><br><span class="line">      所以模式串子串的最长前缀肯定跟文本串子串的最长后缀有匹配。</span><br><span class="line"></span><br><span class="line">      所以下次模式串匹配，只需要从最长前缀的末尾重新匹配即可（回退到上一个匹配的点）</span><br><span class="line"></span><br><span class="line">      因为模式串子串前缀已经和文本串子串后缀匹配过了。（理解好这个）</span><br><span class="line"></span><br><span class="line">   5. 因为前缀表：记录模式串中从0到i（包括），有多大长度的相同前后缀，所以当不匹配时（当前点最长相同前后缀为0），回退的时候是看上一个点。</span><br><span class="line"></span><br><span class="line">7. 用next数组来做文本串和模式串的匹配和构造next数组一样，只是i从0开始而已。</span><br><span class="line"></span><br><span class="line">8. KMP的时间复杂度分析（摊还分析）：对模式串用了O(m)，对文本串用O（n），共O(n+m)</span><br><span class="line"></span><br><span class="line">   虽然匹配失败时，指针会不断地根据next数组向左回退，看似时间复杂度会很高。但考虑匹配成功时，指针会向右移动一个位置，这一部分对应的时间复杂度为 O(n+m)。又因为向左移动的次数不会超过向右移动的次数，所以总的还是O(n+m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">到此KMP基本内容学习完毕，开始做题</span><br><span class="line"></span><br><span class="line">#### 6、实现 strStr()</span><br><span class="line"></span><br><span class="line">[找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)</span><br><span class="line"></span><br><span class="line">1. 双指针，暴力匹配，每次匹配不上，模式串从头开始。</span><br><span class="line">2. KMP，当`j==len`时，模式串匹配成功，返回`i+1-len`即文本串初次匹配成功子串的起点</span><br><span class="line"></span><br><span class="line">一定要转char数组做！`.charAt`很慢：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        char []s1=needle.toCharArray();</span><br><span class="line">        int len1 = needle.length();</span><br><span class="line">        int len2 = haystack.length();</span><br><span class="line"></span><br><span class="line">        int [] next=new int [len1];</span><br><span class="line">        int j=0;//前缀的最后一位</span><br><span class="line">        next[0]=0;</span><br><span class="line">        for(int i=1;i&lt;len1;i++)&#123;</span><br><span class="line">            while(j&gt;0&amp;&amp;s1[i]!=s1[j])j=next[j-1];</span><br><span class="line">            if(s1[i]==s1[j])j++;</span><br><span class="line">            next[i]=j;//从1到i的最长相等前后缀</span><br><span class="line">        &#125;</span><br><span class="line">        char []s2 = haystack.toCharArray();</span><br><span class="line">        j=0;</span><br><span class="line">        for(int i=0;i&lt;len2;i++)&#123;</span><br><span class="line">            while(j&gt;0&amp;&amp;s2[i]!=s1[j])j=next[j-1];//j是模式串</span><br><span class="line">            if(s2[i]==s1[j])j++;</span><br><span class="line">            if(j==len1)return i-len1+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h4 id="7、重复的子字符串"><a href="#7、重复的子字符串" class="headerlink" title="7、重复的子字符串"></a>7、重复的子字符串</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></p>
<p>法一：</p>
<ul>
<li>匹配字符串，如果s由重复字符串组成，那么两个s拼接，掐头去尾</li>
<li>中间还会有s字符串，用contain即可</li>
<li>理由：上一个重复子串的后缀和下一个重复子串的前缀必能再组成一个<code>s</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String ss=s.substring(<span class="number">1</span>,s.length())+s.substring(<span class="number">0</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ss.contains(s))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<ul>
<li><p>KMP，在由重复子串组成的字符串中，最长相等前后缀不包含的子串就是最小重复子串，</p>
</li>
<li><p>求出最小重复子串的长度，如果<strong>该长度不为0</strong>并且能被s的长度整除，则可由最小重复字符串组成s。</p>
</li>
<li><p>最小重复子串的长度&#x3D;s的长度-最长相等前后缀的长度</p>
</li>
</ul>
<p>如下图：ab在前缀的最后和后缀的最前都有不包含的情况，所以ab是最小重复字符串</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200957.png" alt="image-20231014104930655"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len-(next[len-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(next[len-<span class="number">1</span>]&gt;<span class="number">0</span>&amp;&amp;len%(len-(next[len-<span class="number">1</span>]))==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>



<h4 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h4><p>注意库函数的时间复杂度，否则面试时用了库函数分析不出时间复杂度就寄了。</p>
<p>比如：使用for循环里调用库函数erase来移除元素，这其实是O(n^2)的操作，因为erase就是O(n)的操作</p>
<h2 id="五、栈与队列"><a href="#五、栈与队列" class="headerlink" title="五、栈与队列"></a>五、栈与队列</h2><p>前提：</p>
<ol>
<li>java中 stack 是容器么？</li>
<li>我们使用的stack是属于哪个版本的STL？</li>
<li>我们使用的STL中stack是如何实现的？</li>
<li>stack 提供迭代器来遍历stack空间么？</li>
</ol>
<h4 id="1、用栈实现队列"><a href="#1、用栈实现队列" class="headerlink" title="1、用栈实现队列"></a>1、用栈实现队列</h4><ol>
<li><p>很奇怪的bug</p>
<p>这两几乎一模一样，为什么下面的代码不行，因为，在写了个自己的empty函数在类里面，stack优先调用类里的同名empty（而同名empty要检查栈1和栈2是否同时为空，自然出错），就不会再调用自己的empty了。</p>
</li>
<li><pre><code class="java">/** Removes the element from in front of queue and returns that element. */
   public int pop() &#123;
       int res=0;
       while(!stack1.isEmpty())&#123;
           stack2.push(stack1.pop());
       &#125;
       if(!stack2.isEmpty())&#123;
           res=stack2.pop();
       &#125;
       while(!stack2.isEmpty())&#123;
           stack1.push(stack2.pop());
       &#125;
       return res;
   &#125;
   /** Returns whether the queue is empty. */
   public boolean empty() &#123;
       return stack2.isEmpty()&amp;&amp;stack1.isEmpty();
   &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. ```java</span><br><span class="line">   public int pop() &#123;</span><br><span class="line">       int result=0;</span><br><span class="line">       whlie(!st1.empty())&#123;</span><br><span class="line">           st2.push(st1.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       if(!st2.empty())&#123;</span><br><span class="line">           result=st2.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       while(!st2.empty())&#123;//直接调用下面的empty()了</span><br><span class="line">           st1.push(st2.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br><span class="line">   public boolean empty() &#123;</span><br><span class="line">       if(st1.empty()&amp;&amp;st2.empty())return true;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="2、用队列实现栈"><a href="#2、用队列实现栈" class="headerlink" title="2、用队列实现栈"></a>2、用队列实现栈</h4><ol>
<li><p>和栈实现队列不一样，两个栈倒腾，顺序会改变，两个队列倒腾，先进还是先出，顺序没改变</p>
</li>
<li><p>所以：把除最后一个元素以外的元素弹出后再添加到队列尾部即可</p>
</li>
<li><p>下面这两段几乎一模一样，为什么下面的出错了，有空用IDEA跑跑看怎么回事</p>
</li>
<li><pre><code class="java">class MyStack &#123;
    Queue&lt;Integer&gt; queue1; // 和栈中保持一样元素的队列
    public MyStack() &#123;
        queue1 = new LinkedList&lt;&gt;();
    &#125;
    
    public void push(int x) &#123;
        queue1.add(x);
    &#125;
    
    public int pop() &#123; 
        rePosition();
        return queue1.poll();
    &#125;
    
    public int top() &#123;
        rePosition();
        int result = queue1.poll();
        queue1.add(result);
        return result;      
    &#125;
    
    public boolean empty() &#123;
        return queue1.isEmpty();
    &#125;
    public void rePosition()&#123;
        int size = queue1.size();
        size--;//看清楚，这里先size--了！
        while(size--&gt;0)
            queue1.add(queue1.poll());
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 另一段代码</span><br><span class="line"></span><br><span class="line">   因为比如压入1和2，队列size为2，如果为n--，会跑两次，会把1添加到2后，然后再把2添加到1后。</span><br><span class="line"></span><br><span class="line">   应该为--n&gt;0即可。实际只用跑n-1词，原因参考第二点</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   public int pop() &#123; </span><br><span class="line">           int n=queue1.size();</span><br><span class="line">           while(n--&gt;0)&#123;</span><br><span class="line">               queue1.add(queue1.poll());</span><br><span class="line">           &#125;</span><br><span class="line">           return queue1.poll();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       public int top() &#123;</span><br><span class="line">           int n=queue1.size();</span><br><span class="line">           while(n--&gt;0)&#123;</span><br><span class="line">               queue1.add(queue1.poll());</span><br><span class="line">           &#125;</span><br><span class="line">           int result = queue1.poll();</span><br><span class="line">           queue1.add(result);</span><br><span class="line">           return result;      </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="3、对对碰"><a href="#3、对对碰" class="headerlink" title="3、对对碰"></a>3、对对碰</h4><p>1、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">删除字符串中的所有相邻重复项</a></p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200958.gif"></p>
<p>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式求值</a></p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200959.gif"></p>
<ol>
<li><p>学会用valueOf，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b=<span class="number">1000</span>;</span><br><span class="line">String s=String.valueOf(b);<span class="comment">//把b转为字符串</span></span><br><span class="line"><span class="type">int</span> b=Integer.valueOf(s);<span class="comment">//把s转为整数</span></span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="java">&quot;+&quot;.equals(s)//快速比较两个字符串是否相等，用charAt(i)还要一个一个串比，很麻烦
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4、求解出栈顺序种类</span><br><span class="line"></span><br><span class="line">##### 1、递归求解：</span><br><span class="line"></span><br><span class="line">我们把n个元素的出栈个数的记为f(n), 那么对于1,2,3, 我们很容易得出：</span><br><span class="line"></span><br><span class="line">    f(1) = 1     //即 1</span><br><span class="line">    </span><br><span class="line">    f(2) = 2     //即 12、21</span><br><span class="line">    </span><br><span class="line">    f(3) = 5     //即 123、132、213、321、231</span><br><span class="line"></span><br><span class="line">然后我们来考虑`f(4),` 我们给4个元素编号为a,b,c,d, 那么考虑：元素a只可能出现在1号位置，2号位置，3号位置和4号位置（很容易理解，一共就4个位置，比如abcd,元素a就在1号位置）。</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line"></span><br><span class="line">    1) 如果元素a在1号位置，那么只可能a进栈，马上出栈，此时还剩元素b、c、d等待操作，就是子问题f(3)；</span><br><span class="line">    2) 如果元素a在2号位置，那么一定有一个元素比a先出栈，即有f(1)种可能顺序（只能是b），还剩c、d，即f(2)，根据乘法原理，一共的顺序个数为`f(1) * f(2)；`</span><br><span class="line">    3) 如果元素a在3号位置，那么一定有两个元素比1先出栈，即有f(2)种可能顺序（只能是b、c），还剩d，即f(1)，根据乘法原理，一共的顺序个数为`f(2) * f(1)；`</span><br><span class="line"></span><br><span class="line">  4) 如果元素a在4号位置，那么一定是a先进栈，最后出栈，那么元素b、c、d的出栈顺序即是此小问题的解，即f(3)；</span><br><span class="line">  4) 结合所有情况，即`f(4) = f(3) + f(2) * f(1) + f(1) * f(2) + f(3);`</span><br><span class="line"></span><br><span class="line">为了规整化，我们定义f(0) = 1；于是f(4)可以重新写为：</span><br><span class="line"></span><br><span class="line">`f(4) = f(0)*f(3) + f(1)*f(2) + f(2) * f(1) + f(3)*f(0)`</span><br><span class="line"></span><br><span class="line">然后我们推广到n，推广思路和n=4时完全一样，于是我们可以得到：</span><br><span class="line"></span><br><span class="line">`f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)*f(0)`</span><br><span class="line"></span><br><span class="line">有了递归式就可以编程求解了。</span><br><span class="line"></span><br><span class="line">##### 2、组合数：</span><br><span class="line"></span><br><span class="line">通项公式：</span><br><span class="line"></span><br><span class="line">![image-20230824104550377](测试.assets/202310292200960.png)</span><br><span class="line"></span><br><span class="line">卡塔兰数是一个常见的组合数学问题，它可以用来计算很多问题的可能情况数，比如合法的括号匹配，二叉搜索树的个数，出栈顺序的个数等等。</span><br><span class="line"></span><br><span class="line">卡塔兰数还有一个递推公式是**h(n)=h(0)h(n-1)+h(1)h(n-2)+…+h(n-1)h(0)**，也就是说第n项等于前面n-1项两两相乘的和（也就是上面推导的公式）。</span><br><span class="line"></span><br><span class="line">推导：</span><br><span class="line"></span><br><span class="line">我们可以用一个01字符串来表示出栈顺序，其中0表示入栈，1表示出栈。例如ABCDEF的出栈顺序为CBAEDF，可以表示为001001110110。</span><br><span class="line"></span><br><span class="line">那么对于任意一个合法的出栈顺序，它必须满足以下两个条件： </span><br><span class="line"></span><br><span class="line">- 0和1的个数相等，因为每次出栈都要对应一个入栈。 2n个位置选n个放0，故有C(2n,n)种选择方法。</span><br><span class="line">- 任意一个前缀子串中，0的个数不小于1的个数，因为不能在没有元素入栈的情况下进行出栈。</span><br><span class="line"></span><br><span class="line">然后...问题转化为：求解有多少种这样的01字符串满足这个条件，好难看懂，算了！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 5、[滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)</span><br><span class="line"></span><br><span class="line">考察：根据题目要求实现数据结构的能力</span><br><span class="line"></span><br><span class="line">这里面涉及很多思考，要考虑很多数据结构，下面直接给答案：</span><br><span class="line"></span><br><span class="line">设计单调队列的时候，pop，和push操作要保持如下规则：</span><br><span class="line"></span><br><span class="line">1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</span><br><span class="line">2. push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</span><br><span class="line"></span><br><span class="line">既保证队头到队尾单调递减，又保证队列里都是**有可能成为窗口里最大值的元素**，不需要维护窗口的所有元素</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        if(nums.length==1)return nums;</span><br><span class="line">        int len = nums.length-k+1;</span><br><span class="line">        int[] res = new int [len];</span><br><span class="line">        My_deque my_deque = new My_deque();//调用默认构造</span><br><span class="line">        for(int i=0;i&lt;k;i++)&#123;</span><br><span class="line">            my_deque.push(nums[i]);//初始化队列</span><br><span class="line">        &#125;</span><br><span class="line">        int index = 0;</span><br><span class="line">        res[index++] = my_deque.front();//初始化结果集</span><br><span class="line">        for(int i=k;i&lt;nums.length;i++)&#123;</span><br><span class="line">            my_deque.pop(nums[i-k]);//弹出窗口尾部</span><br><span class="line">            my_deque.push(nums[i]);//插入窗口头部</span><br><span class="line">            res[index++] = my_deque.front();//获取当前滑动窗口最大值</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public class My_deque&#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">        public void pop(int val)&#123;</span><br><span class="line">            // 队列不能为空</span><br><span class="line">            if(!deque.isEmpty()&amp;&amp;val==deque.peek())&#123;</span><br><span class="line">                deque.poll();//如果当前要移除的元素等于队首，则弹出队首</span><br><span class="line">            &#125;</span><br><span class="line">            // 否则不用动，因为push的时候已经弹了</span><br><span class="line">        &#125;</span><br><span class="line">        public void push(int val)&#123;</span><br><span class="line">            // 要和队尾比较，把队尾小于该元素的都弹出，再入栈就是正确位置</span><br><span class="line">            // 保持队列从队头到队尾单调递减</span><br><span class="line">            // 注意兜底条件：队列不能为空</span><br><span class="line">            while(!deque.isEmpty()&amp;&amp;val&gt;deque.getLast())&#123;//等价peekLast()</span><br><span class="line">                deque.removeLast();//把队尾弹出，用pollLast也可以</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        public int front()&#123;</span><br><span class="line">            return deque.peek();//查询当前滑动窗口最大值，直接返回队首</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>补充：</p>
<p>Java中有两个Deque实现：<code>ArrayDeque</code>和<code>LinkedList</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="6、前-K-个高频元素"><a href="#6、前-K-个高频元素" class="headerlink" title="6、前 K 个高频元素"></a>6、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">前 K 个高频元素</a></h4><p>本题是优先队列的应用</p>
<h5 id="1、优先队列介绍"><a href="#1、优先队列介绍" class="headerlink" title="1、优先队列介绍"></a>1、优先队列介绍</h5><p>Java优先队列默认排序从小到大，底层实现是小根堆</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<h5 id="2、基本操作"><a href="#2、基本操作" class="headerlink" title="2、基本操作"></a>2、基本操作</h5><p>优先队列总是从队头取元素，从队尾添加元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认从小到大排序，小顶堆，先弹小的元素，先弹队头，从队头到队尾递增</span></span><br><span class="line">PriorityQueue&lt;String&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line">PriorityQueue&lt;String&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br><span class="line"><span class="comment">//其余操作和队列一样！</span></span><br><span class="line">priorityQueue.offer(<span class="string">&quot;沉默王二&quot;</span>);<span class="comment">//队尾</span></span><br><span class="line">priorityQueue.poll();<span class="comment">//队头</span></span><br></pre></td></tr></table></figure>

<h5 id="3、基本思路"><a href="#3、基本思路" class="headerlink" title="3、基本思路"></a>3、基本思路</h5><h6 id="1、小顶堆"><a href="#1、小顶堆" class="headerlink" title="1、小顶堆"></a>1、小顶堆</h6><p>本题最好使用小顶堆，维护堆大小为K，超过，则把当前最小的元素弹出（也就是堆头）</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200961.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法2：基于小顶堆实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent2(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">        map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);<span class="comment">//用getOrDefault消除if-else</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">    <span class="comment">//出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">        <span class="keyword">if</span>(pq.size()&lt;k)&#123;<span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">            <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">        ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2、大顶堆"><a href="#2、大顶堆" class="headerlink" title="2、大顶堆"></a>2、大顶堆</h6><p>如果用大顶堆，就不能维护size为K的堆了，因为超过K个元素，把堆头（当前最大元素）弹走，不合理</p>
<p>只能把所有元素都插入堆中，最后再取前K个元素，空间复杂度较高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法1：基于大顶堆实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent1(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">        map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">    <span class="comment">//出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)</span></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2)-&gt;pair2[<span class="number">1</span>]-pair1[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;<span class="comment">//大顶堆需要对所有元素进行排序</span></span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;<span class="comment">//依次从队头弹出k个,就是出现频率前k高的元素</span></span><br><span class="line">        ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何确定排序方式？Java的比较器都是这样判断的：</p>
<p>按照pair1[1]-pair2[1]的结果进行排序</p>
<ul>
<li>如果pair1[1]-pair2[1]的结果为负数，则pair1排在pair2前面；（前一个元素小，排前面，所以是升序）</li>
<li>如果结果为正数，则pair2排在pair1前面；</li>
<li>如果结果为0，则pair1和pair2的顺序不变</li>
</ul>
<p>而按照pair2[1]-pair1[1]的结果进行排序</p>
<ul>
<li>如果pair2[1]-pair1[1]的结果为负数，则pair2排在pair1前面；（后一个元素小，排前面，所以是降序）</li>
</ul>
<p>实在不知道就输出一遍！</p>
<h2 id="六、二叉树"><a href="#六、二叉树" class="headerlink" title="六、二叉树"></a>六、二叉树</h2><h4 id="1、基础知识："><a href="#1、基础知识：" class="headerlink" title="1、基础知识："></a>1、基础知识：</h4><h5 id="种类："><a href="#种类：" class="headerlink" title="种类："></a>种类：</h5><ol>
<li>满二叉树</li>
<li>完全二叉树：必须从左到右铺叶子</li>
<li>二叉搜索树</li>
<li>AVL平衡二叉搜索树：左右子树高度差不超过1</li>
</ol>
<h5 id="存储方式："><a href="#存储方式：" class="headerlink" title="存储方式："></a>存储方式：</h5><ol>
<li><p>链表</p>
</li>
<li><p>数组来存储二叉树如何遍历的呢？</p>
<p>如果父节点的数组下标是 i，那么它的左孩子就是 <code>i * 2 + 1</code>，右孩子就是 <code>i * 2 + 2</code>。</p>
</li>
</ol>
<h5 id="遍历顺序："><a href="#遍历顺序：" class="headerlink" title="遍历顺序："></a>遍历顺序：</h5><p>深度优先：前中后序遍历（以中节点的位置划分前中后），迭代用栈</p>
<p>广度优先：层次遍历，迭代用队列</p>
<h4 id="2、遍历："><a href="#2、遍历：" class="headerlink" title="2、遍历："></a>2、遍历：</h4><h5 id="1、递归"><a href="#1、递归" class="headerlink" title="1、递归"></a>1、递归</h5><p>对于前中后序遍历：都类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preorder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preorder(root.left, result);</span><br><span class="line">        preorder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、不统一迭代格式："><a href="#2、不统一迭代格式：" class="headerlink" title="2、不统一迭代格式："></a>2、不统一迭代格式：</h5><p>用栈时要注意，进栈出栈顺序相反</p>
<p>对于前后两种遍历，访问和处理（加入结果数组）都是中节点，中节点和空节点不进栈</p>
<p>前：进栈右左，出栈左右，存入结果为中左右</p>
<p>后：进栈左右，出栈右左，存入结果为中右左，最后反转得到左右中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历，由于访问节点和处理节点的顺序相反，所以不能和上面统一：</p>
<p>需要先遍历到最左节点，才开始处理，前面两种都是直接处理中节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>(); <span class="comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);     <span class="comment">// 中</span></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">                <span class="comment">// 如果右边为空，会继续弹栈，</span></span><br><span class="line">                <span class="comment">// 如果右边不为空，会继续压栈，直到找到右子树的最左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3、统一迭代风格："><a href="#3、统一迭代风格：" class="headerlink" title="3、统一迭代风格："></a>3、统一迭代风格：</h5><p>使用<code>null</code>节点标记中节点（访问过，但未处理）</p>
<p>进栈 中节点，null节点，出栈null节点（遇到标记多弹一次），中节点</p>
<p>这样就能保证访问和遍历顺序一样，但性能是三种遍历最差的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(curr!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.pop();<span class="comment">//弹中节点，防止下面误操作，统一逻辑</span></span><br><span class="line">                <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)stack.push(curr.right);</span><br><span class="line">                <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)stack.push(curr.left);</span><br><span class="line">                stack.push(curr);</span><br><span class="line">                stack.push(<span class="literal">null</span>);<span class="comment">//标记中节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stack.pop();<span class="comment">//弹标记</span></span><br><span class="line">                curr=stack.pop();</span><br><span class="line">                res.add(curr.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、层次遍历："><a href="#4、层次遍历：" class="headerlink" title="4、层次遍历："></a>4、层次遍历：</h5><p>只推荐非递归写法。</p>
<h6 id="自顶向下："><a href="#自顶向下：" class="headerlink" title="自顶向下："></a>自顶向下：</h6><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历</a></p>
<p>外层是层数，内层是每层的节点数。</p>
<p>注意要提前把<code>queue.size()</code>取出来，因为它在内层是动态变化的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue &lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List &lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(curr.val);</span><br><span class="line">                <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)queue.offer(curr.left);</span><br><span class="line">                <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)queue.offer(curr.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="自底向上："><a href="#自底向上：" class="headerlink" title="自底向上："></a>自底向上：</h6><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107.二叉树的层次遍历II</a></p>
<p>使用链表存结果，然后头插法即可，和上面只有两行区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">res.addFirst(tmp);<span class="comment">//把tmp插前头</span></span><br></pre></td></tr></table></figure>

<h6 id="如何获取每层最后一个元素："><a href="#如何获取每层最后一个元素：" class="headerlink" title="如何获取每层最后一个元素："></a>如何获取每层最后一个元素：</h6><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199.二叉树的右视图</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">res.add(tmp.getLast());<span class="comment">//LinkedList可以使用getLast获取最后一个元素</span></span><br></pre></td></tr></table></figure>

<h6 id="如何保存层次遍历的前一个元素："><a href="#如何保存层次遍历的前一个元素：" class="headerlink" title="如何保存层次遍历的前一个元素："></a>如何保存层次遍历的前一个元素：</h6><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116.填充每个节点的下一个右侧节点指针</a></p>
<p>保存pre节点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> queue.poll();<span class="comment">//取每层头节点</span></span><br><span class="line">    <span class="keyword">if</span>(pre.left!=<span class="literal">null</span>) queue.offer(pre.left);</span><br><span class="line">    <span class="keyword">if</span>(pre.right!=<span class="literal">null</span>) queue.offer(pre.right);</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>) queue.offer(curr.left);</span><br><span class="line">        <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>) queue.offer(curr.right);</span><br><span class="line">        pre.next = curr;<span class="comment">//让前一个节点的next指向本节点</span></span><br><span class="line">        pre = next; <span class="comment">//保存新的前一个节点</span></span><br><span class="line">        size--;</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="最大深度和最小深度"><a href="#最大深度和最小深度" class="headerlink" title="最大深度和最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">最大深度</a>和<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">最小深度</a></h6><p>最大深度就是层次遍历完，最小深度就是层次遍历过程中找到第一个叶子节点直接返回。</p>
<p>最小深度如果用后序遍历：</p>
<ul>
<li>注意对于最小深度的判断，是叶子节点到根节点！</li>
<li>左子树为空，那么最小深度应该是右子树最小深度+1，因为本层左右子树不全为空，不是叶子节点。</li>
</ul>
<h5 id="5、反转二叉树"><a href="#5、反转二叉树" class="headerlink" title="5、反转二叉树"></a>5、反转二叉树</h5><p>层序遍历或者前后都可以遇到处理节点后直接反转（类似swap两个数）节点的左右子树。</p>
<p>中序遍历，要注意翻转中节点后，右子树就在左边了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == NULL) <span class="keyword">return</span> root;</span><br><span class="line">        invertTree(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line">        swap(root-&gt;left, root-&gt;right);  <span class="comment">// 中</span></span><br><span class="line">        invertTree(root-&gt;left);         <span class="comment">// 注意 这里依然要遍历左孩子，因为中间节点已经翻转了</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果用的统一迭代风格就不用考虑这个问题。</p>
<h5 id="6、对称二叉树"><a href="#6、对称二叉树" class="headerlink" title="6、对称二叉树"></a>6、对称二叉树</h5><p>同时操作两棵树，注意不是同时比较两棵树的左孩子、右孩子</p>
<p>而是一颗比较左，另一颗就要比较右</p>
<p>确定两棵树的遍历顺序，一棵左右中，另一颗中右中</p>
<p>由于需要遍历完全两棵树，所以需要返回值来接住上一层递归的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两孩子值相等别直接返回true，还要继续往下判断</span></span><br><span class="line"><span class="type">bool</span> <span class="variable">outside</span> <span class="operator">=</span> compare(left-&gt;left, right-&gt;right);   <span class="comment">// 左子树：左、 右子树：右</span></span><br><span class="line"><span class="type">bool</span> <span class="variable">inside</span> <span class="operator">=</span> compare(left-&gt;right, right-&gt;left);    <span class="comment">// 左子树：右、 右子树：左</span></span><br><span class="line"><span class="type">bool</span> <span class="variable">isSame</span> <span class="operator">=</span> outside &amp;&amp; inside;                    <span class="comment">// 左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line"><span class="keyword">return</span> isSame;</span><br></pre></td></tr></table></figure>

<p>非迭代写法：其实只是拿个容器把要比较的两个孩子按顺序放进去，再按顺序取出来罢了。</p>
<h4 id="7、完全二叉树的节点个数（-）"><a href="#7、完全二叉树的节点个数（-）" class="headerlink" title="7、完全二叉树的节点个数（!）"></a>7、完全二叉树的节点个数（!）</h4><p>递归，层次遍历，都可以做，O(n)。</p>
<p>还可以利用满二叉树性质：</p>
<h6 id="怎么判断完全二叉树是不是满二叉树："><a href="#怎么判断完全二叉树是不是满二叉树：" class="headerlink" title="怎么判断完全二叉树是不是满二叉树："></a>怎么判断完全二叉树是不是满二叉树：</h6><p>如果递归向左遍历的深度等于递归向右遍历的深度，那就是满二叉树（记住前提是完全二叉树）</p>
<p>思路：递归，如果是满二叉树，利用满二叉树性质算节点数：<code>2^h-1</code></p>
<p>时间复杂度O(log n × log n)，比O(n)快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == nullptr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* left = root-&gt;left;</span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> <span class="number">0</span>, rightDepth = <span class="number">0</span>; <span class="comment">// 这里初始为0是有目的的，为了下面求指数方便</span></span><br><span class="line">        <span class="keyword">while</span> (left) &#123;  <span class="comment">// 求左子树深度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123; <span class="comment">// 求右子树深度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度计算：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/labuladong/p/13975114.html">如何计算完全二叉树的节点数 - labuladong - 博客园 (cnblogs.com)</a></p>
<h4 id="8、平衡二叉树的判断"><a href="#8、平衡二叉树的判断" class="headerlink" title="8、平衡二叉树的判断"></a>8、平衡二叉树的判断</h4><p>只考虑递归算法：</p>
<p>高度用后序遍历（求最大深度，也可以用后序，因为最大高度等于最大深度）</p>
<p>深度用前序遍历</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200962.png" alt="image-20230807121813852"></p>
<p>思路：求左右子树高度，如果左右子树高度之差大于1，返回-1，代表后续不用比较了。否则继续比较，求出最大高度。最后判断最大高度是不是-1即可</p>
<h4 id="9、二叉树的所有路径："><a href="#9、二叉树的所有路径：" class="headerlink" title="9、二叉树的所有路径："></a>9、二叉树的所有路径：</h4><p>使用前序遍历，方便让父亲指向儿子，回溯。</p>
<h4 id="10、左叶子之和："><a href="#10、左叶子之和：" class="headerlink" title="10、左叶子之和："></a>10、左叶子之和：</h4><p>1、层次遍历加标记左节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue &lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(curr==<span class="literal">null</span>)&#123;</span><br><span class="line">                    size--;<span class="comment">//吐null节点</span></span><br><span class="line">                    curr=queue.poll();</span><br><span class="line">                    <span class="keyword">if</span>(curr.left==<span class="literal">null</span>&amp;&amp;curr.right==<span class="literal">null</span>)&#123;<span class="comment">//叶子节点</span></span><br><span class="line">                        sum+=curr.val;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="literal">null</span>);<span class="comment">//标记左节点</span></span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)queue.offer(curr.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、递归，加用父亲来判断是不是左叶子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftValue</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightValue</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);  <span class="comment">// 右</span></span><br><span class="line">                                                       </span><br><span class="line">        <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123; </span><br><span class="line">            midValue = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> midValue + leftValue + rightValue;  <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11、树左下角的值："><a href="#11、树左下角的值：" class="headerlink" title="11、树左下角的值："></a>11、树左下角的值：</h4><p>1、层次遍历</p>
<p>2、前序遍历：</p>
<p>求深度用前序遍历，递归最快，怎么保证是最左节点？因为记录了当前深度，只有当前深度大于最大深度才会记录值，也就是每一层只会记一个节点，自然是左节点啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//前序遍历找最大深度</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        function(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(TreeNode curr,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.left==<span class="literal">null</span>&amp;&amp;curr.right==<span class="literal">null</span>)&#123;<span class="comment">//叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(depth&gt;maxDepth)&#123;</span><br><span class="line">                maxDepth=depth;</span><br><span class="line">                res=curr.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            function(curr.left,depth+<span class="number">1</span>);<span class="comment">//把回溯隐藏了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            function(curr.right,depth+<span class="number">1</span>);<span class="comment">//depth+1，递归完回来自动回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归总结："><a href="#递归总结：" class="headerlink" title="递归总结："></a>递归总结：</h4><h5 id="1、返回值："><a href="#1、返回值：" class="headerlink" title="1、返回值："></a>1、返回值：</h5><ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 </li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</li>
</ul>
<h5 id="2、是否让空进递归："><a href="#2、是否让空进递归：" class="headerlink" title="2、是否让空进递归："></a>2、是否让空进递归：</h5><p>不让空进递归终止条件，是遇到叶子节点就终止，因为空节点不会进入递归。</p>
<p>让空进递归的终止条件，是遇到空节点，也就是数组区间为0，就终止了。</p>
<h5 id="3、搜索一条边还是搜索整棵树？"><a href="#3、搜索一条边还是搜索整棵树？" class="headerlink" title="3、搜索一条边还是搜索整棵树？"></a>3、搜索一条边还是搜索整棵树？</h5><p>在递归函数有返回值的情况下：</p>
<p>如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，（第一点的情况2）</p>
<p>如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。（第一点的情况3）</p>
<p>搜索一条边的写法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (递归函数(root-&gt;left)) return ;</span><br><span class="line">if (递归函数(root-&gt;right)) return ;</span><br></pre></td></tr></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<h4 id="12、路径之和："><a href="#12、路径之和：" class="headerlink" title="12、路径之和："></a>12、路径之和：</h4><p>求根节点到叶子节点的路径之和，递归回溯法，记得用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值，而不是用累加。</p>
<p>路径之和Ⅱ：</p>
<p>1、要注意添加一条完整路径时要生成新的list来添加，否则递归返回会把之前添加的覆盖，最后只剩头节点</p>
<p>2、添加节点要在if-else外统一添加，如果在每个if-else里手动添加，那就要想清楚添加了该节点后要不要回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt;tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        function(root,tmp,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(TreeNode root,List&lt;Integer&gt; tmp,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        tmp.add(root.val);<span class="comment">//最后一个节点也要添加</span></span><br><span class="line">        <span class="keyword">if</span>(root.val==sum&amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">            <span class="comment">//特别注意，要用tmp生成新的List再添加，否则递归返回时最后只剩下根节点了</span></span><br><span class="line">            <span class="comment">//System.out.println(res);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)<span class="keyword">return</span>;<span class="comment">//到叶子节点，不满足条件，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">            function(root.left,tmp,sum-root.val);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">            function(root.right,tmp,sum-root.val);</span><br><span class="line">            tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不统一添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(TreeNode root,List&lt;Integer&gt; tmp,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val==sum&amp;&amp;root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">        tmp.add(root.val);<span class="comment">//最后一个节点也要添加</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tmp));</span><br><span class="line">        tmp.remove(tmp.size()-<span class="number">1</span>);<span class="comment">//这里也要回溯！否则树高四层，递归三层，回退三次，但tmp里有4个数，还会剩一个</span></span><br><span class="line">        <span class="comment">//特别注意，要用tmp生成新的List再添加，否则递归返回时最后只剩下根节点了</span></span><br><span class="line">        <span class="comment">//System.out.println(res);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp;root.right==<span class="literal">null</span>)<span class="keyword">return</span>;<span class="comment">//到叶子节点，不满足条件，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        function(root.left,tmp,sum-root.val);</span><br><span class="line">        tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">        tmp.add(root.val);</span><br><span class="line">        function(root.right,tmp,sum-root.val);</span><br><span class="line">        tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//System.out.println(tmp);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="13、从后序和中序中构造二叉树："><a href="#13、从后序和中序中构造二叉树：" class="headerlink" title="13、从后序和中序中构造二叉树："></a>13、从后序和中序中构造二叉树：</h4><ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点（注意中序数组的起始）</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<p>中序用后序的最后一个元素作为切割点</p>
<p>后序用中序分割完的数组大小来分割</p>
<p>先中序后分割后序。</p>
<p>注意左闭右开循环不变量原则</p>
<p>切割使用下标索引，所以要传下标索引参数。</p>
<p>要遍历整棵树，且要递归返回根的左右子树，所以要返回值。</p>
<h4 id="14、最大二叉树"><a href="#14、最大二叉树" class="headerlink" title="14、最大二叉树"></a>14、最大二叉树</h4><p>根据数组输入构造二叉树</p>
<p>构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</p>
<p>思路很简单：先找最大值，然后以最大值左右分割数组</p>
<h4 id="15、验证二叉搜索树（-）"><a href="#15、验证二叉搜索树（-）" class="headerlink" title="15、验证二叉搜索树（!）"></a>15、验证二叉搜索树（!）</h4><p>迭代什么时候可以简洁的写？</p>
<p>1、对于不需要遍历整颗二叉搜索树的题，使用迭代法时，由于二叉搜索树有方向性，所以迭代法不需要像传统前中后层次遍历一样。</p>
<p>2、对于需要遍历整颗二叉搜索树的，比如验证二叉搜索树，就需要传统手段。</p>
<p>3、中序遍历二叉搜索树后，会得到有序数组！所以如果真要遍历一般都是中序遍历</p>
<p>坑：</p>
<p>1、验证二叉搜索树不能简单判断左边小于根，右边大于根，因为可能右边的左子树小于根（也就是二叉搜索树左子树上的节点一定全都小于根节点）</p>
<p>2、不能使用全局变量max赋值int最小值来判断节点的递增性，不优雅</p>
<p>3、使用pre节点记录前一个节点的值，这样比较好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//如果初始化为new TreeNode()，那么pre.val的默认值是0</span></span><br><span class="line">    <span class="comment">//这样当root.val也是0时，就会出现错误。</span></span><br><span class="line">    <span class="comment">// 中序遍历过后，二叉搜索树变为有序数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> isValidBST(root.left);<span class="comment">//左</span></span><br><span class="line">        <span class="comment">//记录中序遍历前一个节点，避免设置最小值，题目会有-2^31</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>&amp;&amp;pre.val&gt;=root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//中，如果左边大于右边，那就false</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> isValidBST(root.right);<span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> a&amp;&amp;b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16、最近公共祖先："><a href="#16、最近公共祖先：" class="headerlink" title="16、最近公共祖先："></a>16、最近公共祖先：</h4><p>二叉树的最近公共祖先：</p>
<p>自底向上，需要遍历整棵树，把公共祖先传到根（因为是自底向上的，没到最上面拿不到结果）：</p>
<p>记得把底层结果不断上抛传到根！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//后序遍历，天然的回溯，左右中</span></span><br><span class="line">        <span class="keyword">return</span> function(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">function</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val==p.val) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(root.val==q.val) <span class="keyword">return</span> q;</span><br><span class="line">        <span class="comment">// 左右</span></span><br><span class="line">        TreeNode l=function(root.left,p,q);</span><br><span class="line">        TreeNode r=function(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="literal">null</span>&amp;&amp;r!=<span class="literal">null</span>) <span class="keyword">return</span> root;<span class="comment">//成功找到最近祖先</span></span><br><span class="line">        <span class="comment">// 找到最近祖先之后还要一路把该祖先传到顶</span></span><br><span class="line">        <span class="comment">// 逻辑就是父节点的左孩子为空，右孩子不为空</span></span><br><span class="line">        <span class="comment">// 证明祖先在右孩子找到，把右孩子找到的祖先继续网上抛。</span></span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">null</span>&amp;&amp;r!=<span class="literal">null</span>) <span class="keyword">return</span> r; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉搜索树的最近公共祖先：</p>
<p>自顶向下，不需要遍历整棵树，找到第一个节点值在两个目标之间的就直接返回即可（自顶向下）：</p>
<p>递归的话：搜边，搜到直接返回，不需要键新变量来接返回值</p>
<h4 id="17、二叉搜索树的修改："><a href="#17、二叉搜索树的修改：" class="headerlink" title="17、二叉搜索树的修改："></a>17、二叉搜索树的修改：</h4><h5 id="1、二叉树的插入："><a href="#1、二叉树的插入：" class="headerlink" title="1、二叉树的插入："></a>1、二叉树的插入：</h5><p>注意：如果二叉树为空，返回的是以val为值的新树</p>
<p>不需要重构二叉树，找到空节点直接插进去就行了</p>
<p>学会通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<h5 id="2、二叉树的删除（-）："><a href="#2、二叉树的删除（-）：" class="headerlink" title="2、二叉树的删除（!）："></a>2、二叉树的删除（!）：</h5><p>打了37次才通，草了，一定要想清楚再动手！</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p>第五种情况最重要。</p>
<h6 id="删除节点1："><a href="#删除节点1：" class="headerlink" title="删除节点1："></a>删除节点1：</h6><p>把五种情况全列出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5种终止条件</span></span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(root.val==key)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="literal">null</span>)<span class="keyword">return</span> root.right;<span class="comment">//左边为空，或者左右都为空，返回右子树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.right==<span class="literal">null</span>)<span class="keyword">return</span> root.left;<span class="comment">//右边为空返回左子树</span></span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//左右都不为空</span></span><br><span class="line">        TreeNode curr=root.right;</span><br><span class="line">        <span class="keyword">while</span>(curr.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            curr=curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.left=root.left;<span class="comment">//把左子树挂到右子树的最左子树上</span></span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="删除节点2："><a href="#删除节点2：" class="headerlink" title="删除节点2："></a>删除节点2：</h6><p>总是把目标节点交换（注意是交换不是挂在）右子树的最左边节点（最左节点就是左孩子为空），交换了过后，目标节点的右子树一定为空</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200963.png" alt="image-20230807155358720"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == nullptr) <span class="keyword">return</span> root;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right == nullptr) &#123; <span class="comment">// 这里第二次操作目标值：最终删除的作用</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *cur = root-&gt;right;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;left) &#123;</span><br><span class="line">        cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(root-&gt;val, cur-&gt;val); <span class="comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面两种删除节点的操作之后，剩下的就是递归了：</p>
<p>利用二叉搜索树性质进行剪枝，不需要遍历整棵树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<p>普通二叉搜索树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<h5 id="3、修剪二叉树："><a href="#3、修剪二叉树：" class="headerlink" title="3、修剪二叉树："></a>3、修剪二叉树：</h5><p>不需要重构二叉树，</p>
<p>不要直接<code>TreeNode left = root.right</code>，这是是错误的！因为<code>root.right</code>也要修剪</p>
<p>因为是搜一条边，而不是搜整棵树，所以搜到直接返回，不需要创新变量接住返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;low)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> left; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;high)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> right; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为什么只接一边？比如左子树小于low，就把左子树的左子树全断了，只留右子树？</span></span><br><span class="line">        <span class="comment">// 因为二叉搜索树的左子树全都小于父亲节点，如果左子树不满足，左子树的左子树自然也不满足</span></span><br><span class="line">        root.left=trimBST(root.left,low,high);</span><br><span class="line">        root.right=trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改三部曲里只有删除中的第五种情况是需要大刀阔斧重构二叉树的</p>
<h4 id="18、有序数组变二叉搜索树"><a href="#18、有序数组变二叉搜索树" class="headerlink" title="18、有序数组变二叉搜索树"></a>18、有序数组变二叉搜索树</h4><p>根据下标找中点然后分割就行了</p>
<h4 id="19、二叉搜索树变累加树"><a href="#19、二叉搜索树变累加树" class="headerlink" title="19、二叉搜索树变累加树"></a>19、二叉搜索树变累加树</h4><p>右中左反中序遍历，从最右子树把值累加到最左子树就行了。</p>
<p>8.7号二刷不熟练的题：用满二叉树的性质进行完全二叉树的节点统计（写不熟练）、二叉树最近公共祖先（不会上抛）</p>
<h2 id="七、前缀树"><a href="#七、前缀树" class="headerlink" title="七、前缀树"></a>七、前缀树</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/vincent1997/p/11237389.html">数据结构丨前缀树 - vincent1997 - 博客园 (cnblogs.com)</a></p>
<h3 id="1、基本性质"><a href="#1、基本性质" class="headerlink" title="1、基本性质"></a>1、基本性质</h3><p>又叫字典树、单词查找树或键树，英文：Trie</p>
<p>前缀树的基本性质：</p>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
<li>子节点代表的字符串是由节点本身的原始字符串，以及通往该子节点路径上所有的字符组成的。</li>
<li>节点所有的后代都与该节点相关的字符串有着共同的前缀</li>
</ol>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200964.png" alt="img"></p>
<p>例如，以节点 “b” 为根的子树中的节点表示的字符串，都具有共同的前缀 “b”。反之亦然，具有公共前缀 “b” 的字符串，全部位于以 “b” 为根的子树中，并且具有不同前缀的字符串来自不同的分支</p>
<p>其他性质：</p>
<ul>
<li><p>Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。</p>
</li>
<li><p>查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。</p>
</li>
<li><p>Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 O(m^n)</p>
</li>
</ul>
<h3 id="2、实现-Trie-前缀树"><a href="#2、实现-Trie-前缀树" class="headerlink" title="2、实现 Trie (前缀树)"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)</a></h3><h4 id="1、存储方式："><a href="#1、存储方式：" class="headerlink" title="1、存储方式："></a>1、存储方式：</h4><h5 id="1、数组："><a href="#1、数组：" class="headerlink" title="1、数组："></a>1、数组：</h5><p>如果我们只存储含有字母 <code>a</code> 到 <code>z</code> 的字符串，可以在每个节点中声明一个大小为26的数组来存储其子节点。对于特定字符 <code>c</code>，可以使用 <code>c - &#39;a&#39;</code> 作为索引来查找数组中相应的子节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">	TrieNode[] nextNode=<span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、Map："><a href="#2、Map：" class="headerlink" title="2、Map："></a>2、Map：</h5><p>可以在每个节点中声明一个Hashmap。Hashmap的键是字符，值是相对应的子节点，更省空间，但是比数组慢</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, TrieNode*&gt; children;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外根据需求可以修改Trie的结构。比如我要<strong>查询以str开头的单词数量，查询单词str的数量</strong>，那么就可以在Trie结构种增加两个字段<code>count</code>和<code>prefix</code></p>
<h4 id="2、Trie的基本操作："><a href="#2、Trie的基本操作：" class="headerlink" title="2、Trie的基本操作："></a>2、Trie的基本操作：</h4><h5 id="1、定义类-Trie"><a href="#1、定义类-Trie" class="headerlink" title="1、定义类 Trie"></a>1、定义类 Trie</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">	<span class="type">int</span> count;<span class="comment">//以当前单词结尾的单词数量</span></span><br><span class="line">	<span class="type">int</span> prefix;<span class="comment">//以该处节点之前的字符串为前缀的单词数量</span></span><br><span class="line">	TrieNode[] nextNode=<span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		count=<span class="number">0</span>;</span><br><span class="line">		prefix=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、插入"><a href="#2、插入" class="headerlink" title="2、插入"></a>2、插入</h5><p>描述：向 Trie 中插入一个单词 word</p>
<p>实现：这个操作和构建链表很像。首先从根结点的子结点开始与 word 第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的结点，直到插入完 word 的最后一个字符。同时还要<code>root.count++;</code></p>
<p>表示以该节点结尾的单词数+1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(TrieNode root,String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null||str.<span class="built_in">length</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] c=str.<span class="built_in">toCharArray</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//如果该分支不存在，创建一个新节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.nextNode[c[i]-<span class="string">&#x27;a&#x27;</span>]==null)&#123;</span><br><span class="line">            root.nextNode[c[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        root=root.nextNode[c[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        root.prefix++;<span class="comment">//注意，这一步应该在root修改之后</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以该节点结尾的单词数+1</span></span><br><span class="line">    root.count++;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、查找单词"><a href="#3、查找单词" class="headerlink" title="3、查找单词"></a>3、查找单词</h5><p>描述：查找 Trie 中是否存在单词 word</p>
<p>实现：从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回 false，如果匹配到了最后一个字符，那我们只需判断 <code>root.count</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(TrieNode root,String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] c=str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="comment">//如果该分支不存在，表名该单词不存在</span></span><br><span class="line">        <span class="keyword">if</span>(root.nextNode[c[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在，则继续向下遍历</span></span><br><span class="line">        root=root.nextNode[c[i]-<span class="string">&#x27;a&#x27;</span>];	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果count==0,也说明该单词不存在，只是一部分前缀，并不是完整单词</span></span><br><span class="line">    <span class="keyword">if</span>(root.count==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、前缀匹配"><a href="#4、前缀匹配" class="headerlink" title="4、前缀匹配"></a>4、前缀匹配</h5><p>描述：判断 Trie 中是或有以 prefix 为前缀的单词</p>
<p>实现：和 search 操作类似，只是不需要判断是否是完整单词</p>
<p>因为既然能匹配到最后一个字符（没有分支不存在的情况），那后面一定有单词是以它为前缀的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchPrefix</span><span class="params">(TrieNode root,String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] c=str.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">        <span class="comment">//如果该分支不存在，表明该单词不存在</span></span><br><span class="line">        <span class="keyword">if</span>(root.nextNode[c[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在，则继续向下遍历</span></span><br><span class="line">        root=root.nextNode[c[i]-<span class="string">&#x27;a&#x27;</span>];	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.prefix;<span class="comment">//直接return root.prefix即可，不用判断是否完整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不需要统计数量，那么可以直接使用一个布尔类型的 <code>isEnd</code> 来判断是否是完整单词。</p>
<h3 id="3、添加与搜索单词-数据结构设计"><a href="#3、添加与搜索单词-数据结构设计" class="headerlink" title="3、添加与搜索单词 - 数据结构设计"></a>3、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">添加与搜索单词 - 数据结构设计</a></h3><p>和上一题的区别就在于：带通配符</p>
<p><code>&#39;.&#39;</code> 可以表示任何一个小写字符。</p>
<p>在匹配的过程中，如果遇到了 <code>&#39;.&#39;</code> ，则需要对当前节点的所有子树都进行遍历，只要有任何一个子树能最终匹配完成，那么就代表能匹配完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    vector&lt;TrieNode*&gt; children;<span class="comment">//子节点</span></span><br><span class="line">    <span class="built_in">TrieNode</span>(): <span class="built_in">isWord</span>(<span class="literal">false</span>), <span class="built_in">children</span>(<span class="number">26</span>, <span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">TrieNode</span>()&#123;<span class="comment">//析构函数</span></span><br><span class="line">        <span class="keyword">for</span>(TrieNode* child: children)</span><br><span class="line">            <span class="keyword">if</span>(child) <span class="keyword">delete</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myFind</span><span class="params">(string &amp;str, TrieNode* nowPtr, <span class="type">int</span> nowIndex)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> strSize = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(nowPtr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在前缀树上查询的长度大于等于当前查询的单词的长度，就看是不是结尾</span></span><br><span class="line">    <span class="keyword">if</span>(nowIndex &gt;= strSize)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nowPtr-&gt;isWord)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是通配符，只需要查询当前节点的对应子树，要求分支不为Null，并且递归查询下去能找到完整单词</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[nowIndex] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nowPtr-&gt;children[str[nowIndex] - <span class="string">&#x27;a&#x27;</span>] != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">myFind</span>(str, nowPtr-&gt;children[str[nowIndex] - <span class="string">&#x27;a&#x27;</span>], nowIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//如果是通配符，就遍历当前节点的所有子树，要求分支不为Null，并且递归查询下去能找到完整单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nowPtr-&gt;children[i] != <span class="literal">NULL</span> </span><br><span class="line">               &amp;&amp; <span class="built_in">myFind</span>(str, nowPtr-&gt;children[i], nowIndex+<span class="number">1</span> ))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到一个就可以返回了，后面的子树不用找了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、单词搜索-II"><a href="#4、单词搜索-II" class="headerlink" title="4、单词搜索 II"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search-ii/">单词搜索 II</a></h3><p>困难题暂时告辞</p>
<h3 id="5、9-8日滴滴笔试第二题"><a href="#5、9-8日滴滴笔试第二题" class="headerlink" title="5、9.8日滴滴笔试第二题"></a>5、9.8日滴滴笔试第二题</h3><p>测试用例：第一行表示有n个字符串，如果某个字符串可以由其他任意两个字符串（包括自己）拼接后，去掉一个非空前缀和一个非空后缀得到，那么就称这个字符串是特殊字符串，问有多少个特殊字符串请输出它们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">KPZOKNSTGLUNPPDKPFFW</span><br><span class="line">NDPKU</span><br><span class="line">KPFFWN</span><br><span class="line">CCHXNNY</span><br><span class="line">GWSGZ</span><br><span class="line">NNYCCHX</span><br><span class="line">FMVKSOHOPGZWG</span><br><span class="line">SGZNNYCC</span><br><span class="line">PKUFMVKSOHOPG</span><br><span class="line">CCSGZN</span><br></pre></td></tr></table></figure>

<h4 id="法一：暴力"><a href="#法一：暴力" class="headerlink" title="法一：暴力"></a>法一：暴力</h4><p>过82%，把任意两个字符拼起来然后用<code>substring</code>掐头去尾，再使用<code>contains</code>看看包不包含目标串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意类名必须为 Main, 不要有任何 package xxx 信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 注意 hasNext 和 hasNextLine 的区别</span></span><br><span class="line">        <span class="keyword">while</span>(in.hasNextInt())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                strs[i] = in.next();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(strs[i]);</span><br><span class="line">                    tmp.append(strs[j]);</span><br><span class="line">                    list.add(tmp.substring(<span class="number">1</span>, tmp.length()-<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.contains(strs[i]))&#123;</span><br><span class="line">                        sum++;</span><br><span class="line">                        res.add(strs[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">            res.sort((String::compareTo));</span><br><span class="line">            <span class="keyword">for</span> (String s : res) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="法二：将前后缀存入Hash"><a href="#法二：将前后缀存入Hash" class="headerlink" title="法二：将前后缀存入Hash"></a>法二：将前后缀存入Hash</h4><p>考虑前后缀+HashMap：AC</p>
<p><img src="/%E6%B5%8B%E8%AF%95.assets/202310292200965.png" alt="image-20230908222853213"></p>
<h4 id="法三：前缀树"><a href="#法三：前缀树" class="headerlink" title="法三：前缀树"></a>法三：前缀树</h4><p>这题上前缀树属实复杂，感觉前缀树有点华而不实，力扣上考察的也少，就算笔试遇到也有其他解法。。。。</p>
<p>相当于手写Hash的插入和查找😂。总之本题的关键在于前后缀！如果暴力拼接就会寄！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">//全局前缀树</span></span><br><span class="line">    <span class="type">static</span> Trie trie = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> <span class="built_in">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> n = sc.<span class="built_in">nextInt</span>();</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="comment">//处理输入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ss[i] = sc.<span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字典序</span></span><br><span class="line">        Arrays.<span class="built_in">sort</span>(ss, String::compareTo);</span><br><span class="line">        <span class="comment">//插入前缀树</span></span><br><span class="line">        <span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">            <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">            <span class="comment">//看字符串前缀是否在字典树中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">//通过i，分割字符串成两半，分别搜索前缀和后缀是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(trie, i, s)) &#123;</span><br><span class="line">                    nums++;</span><br><span class="line">                    res.<span class="built_in">add</span>(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//找到一个就可以break了，不用再分割</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理输出</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(nums);</span><br><span class="line">        <span class="keyword">for</span> (String s : res) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">static</span> boolean <span class="title">dfs</span><span class="params">(Trie trie, <span class="type">int</span> start,String s)</span> </span>&#123;</span><br><span class="line">        Trie node = trie;</span><br><span class="line">        <span class="comment">//查找单词前缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s.<span class="built_in">charAt</span>(i);</span><br><span class="line">            <span class="type">int</span> index = ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">            <span class="keyword">if</span> (node == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.cisEnd &amp;&amp; i != s.<span class="built_in">length</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = trie;</span><br><span class="line">        <span class="comment">//查找单词后缀</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s.<span class="built_in">charAt</span>(i);</span><br><span class="line">            <span class="type">int</span> index = ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            node = node.father[index];</span><br><span class="line">            <span class="keyword">if</span> (node == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.fisEnd &amp;&amp; i != <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Trie node = trie;</span><br><span class="line">        <span class="comment">//插入字符串的所有前缀，包括自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s.<span class="built_in">charAt</span>(i);</span><br><span class="line">            <span class="type">int</span> index = ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.child[index] == null) &#123;</span><br><span class="line">                node.child[index] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.cisEnd = <span class="literal">true</span>;</span><br><span class="line">        node = trie;</span><br><span class="line">        <span class="comment">//插入字符串的所有后缀，包括自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">length</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s.<span class="built_in">charAt</span>(i);</span><br><span class="line">            <span class="type">int</span> index = ch - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.father[index] == null) &#123;</span><br><span class="line">                node.father[index] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.father[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.fisEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        Trie[] child;</span><br><span class="line">        Trie[] father;</span><br><span class="line">        boolean cisEnd;<span class="comment">//标记前缀单词是否完整</span></span><br><span class="line">        boolean fisEnd;<span class="comment">//标记后缀单词是否完整</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            child = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">            father = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">            cisEnd = <span class="literal">false</span>;</span><br><span class="line">            fisEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.reflux-sharing.top">Reflux</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.reflux-sharing.top/posts/9daba997.html">https://blog.reflux-sharing.top/posts/9daba997.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.reflux-sharing.top" target="_blank">Reflux-Sharing</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/node-js/">node.js</a><a class="post-meta__tags" href="/tags/hexo/">hexo</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/4a17b156.html" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/4a17b156.html" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-06</div><div class="title">Hello World</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://reflux-project.oss-cn-beijing.aliyuncs.com/butterfly-blog/Drink_103663830_5472279_%E3%81%BE%E3%81%94%E3%81%A4%E3%81%8D.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Reflux</div><div class="author-info__description">liberty will never perish</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/reflux-zzy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">一、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、二分查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">二、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="toc-number">2.0.1.</span> <span class="toc-text">定义的模板：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97"><span class="toc-number">2.0.2.</span> <span class="toc-text">1.反转链表系列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">1、反转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">2、反转链表 II</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">3、两两交换链表中的节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.2.4.</span> <span class="toc-text">4、K 个一组翻转链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E6%8C%87%E9%92%88%E7%B3%BB%E5%88%97%EF%BC%9A"><span class="toc-number">2.0.3.</span> <span class="toc-text">2.双指针系列：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">1.旋转链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">2.删除链表倒数第N个节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">3.链表相交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97"><span class="toc-number">2.0.3.4.</span> <span class="toc-text">4.环形链表系列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.3.5.</span> <span class="toc-text">6.回文链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">2.0.3.6.</span> <span class="toc-text">7.删除链表重复元素</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.4.</span> <span class="toc-text">3.链表排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">5.重排链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">8.排序链表(!)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">三、散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E8%AF%8D%E4%BD%8D"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.有效的字母异词位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">3.0.2.</span> <span class="toc-text">3.快乐数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">3.0.3.</span> <span class="toc-text">4.两数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="toc-number">3.0.4.</span> <span class="toc-text">5.四数相加 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">3.0.5.</span> <span class="toc-text">6.三数之和&amp;四数之和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">四、字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.0.1.</span> <span class="toc-text">1、反转字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II"><span class="toc-number">4.0.2.</span> <span class="toc-text">2、反转字符串 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number">4.0.3.</span> <span class="toc-text">3、替换空格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">4.0.4.</span> <span class="toc-text">4、翻转字符串里的单词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%8A%A8%E6%80%81%E5%8F%A3%E4%BB%A4"><span class="toc-number">4.0.5.</span> <span class="toc-text">5、动态口令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E5%88%9D%E5%AD%A6%E4%B9%A0%EF%BC%9A"><span class="toc-number">4.0.6.</span> <span class="toc-text">KMP算法初学习：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.0.7.</span> <span class="toc-text">7、重复的子字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.0.8.</span> <span class="toc-text">8、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">五、栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">5.0.1.</span> <span class="toc-text">1、用栈实现队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number">5.0.2.</span> <span class="toc-text">2、用队列实现栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E5%AF%B9%E7%A2%B0"><span class="toc-number">5.0.3.</span> <span class="toc-text">3、对对碰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">5.0.4.</span> <span class="toc-text">6、前 K 个高频元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.0.4.1.</span> <span class="toc-text">1、优先队列介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.0.4.2.</span> <span class="toc-text">2、基本操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">5.0.4.3.</span> <span class="toc-text">3、基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%B0%8F%E9%A1%B6%E5%A0%86"><span class="toc-number">5.0.4.3.1.</span> <span class="toc-text">1、小顶堆</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E5%A4%A7%E9%A1%B6%E5%A0%86"><span class="toc-number">5.0.4.3.2.</span> <span class="toc-text">2、大顶堆</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">六、二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A"><span class="toc-number">6.0.1.</span> <span class="toc-text">1、基础知识：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB%EF%BC%9A"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">种类：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.0.1.2.</span> <span class="toc-text">存储方式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">6.0.1.3.</span> <span class="toc-text">遍历顺序：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">6.0.2.</span> <span class="toc-text">2、遍历：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E9%80%92%E5%BD%92"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">1、递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%B8%8D%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">2、不统一迭代格式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E9%A3%8E%E6%A0%BC%EF%BC%9A"><span class="toc-number">6.0.2.3.</span> <span class="toc-text">3、统一迭代风格：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">6.0.2.4.</span> <span class="toc-text">4、层次遍历：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%EF%BC%9A"><span class="toc-number">6.0.2.4.1.</span> <span class="toc-text">自顶向下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%EF%BC%9A"><span class="toc-number">6.0.2.4.2.</span> <span class="toc-text">自底向上：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%AF%8F%E5%B1%82%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9A"><span class="toc-number">6.0.2.4.3.</span> <span class="toc-text">如何获取每层最后一个元素：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%9A%84%E5%89%8D%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%9A"><span class="toc-number">6.0.2.4.4.</span> <span class="toc-text">如何保存层次遍历的前一个元素：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">6.0.2.4.5.</span> <span class="toc-text">最大深度和最小深度</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.0.2.5.</span> <span class="toc-text">5、反转二叉树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.0.2.6.</span> <span class="toc-text">6、对称二叉树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%EF%BC%88-%EF%BC%89"><span class="toc-number">6.0.3.</span> <span class="toc-text">7、完全二叉树的节点个数（!）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">6.0.3.0.1.</span> <span class="toc-text">怎么判断完全二叉树是不是满二叉树：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">6.0.4.</span> <span class="toc-text">8、平衡二叉树的判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%EF%BC%9A"><span class="toc-number">6.0.5.</span> <span class="toc-text">9、二叉树的所有路径：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C%EF%BC%9A"><span class="toc-number">6.0.6.</span> <span class="toc-text">10、左叶子之和：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC%EF%BC%9A"><span class="toc-number">6.0.7.</span> <span class="toc-text">11、树左下角的值：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">6.0.8.</span> <span class="toc-text">递归总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A"><span class="toc-number">6.0.8.1.</span> <span class="toc-text">1、返回值：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%98%AF%E5%90%A6%E8%AE%A9%E7%A9%BA%E8%BF%9B%E9%80%92%E5%BD%92%EF%BC%9A"><span class="toc-number">6.0.8.2.</span> <span class="toc-text">2、是否让空进递归：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%90%9C%E7%B4%A2%E4%B8%80%E6%9D%A1%E8%BE%B9%E8%BF%98%E6%98%AF%E6%90%9C%E7%B4%A2%E6%95%B4%E6%A3%B5%E6%A0%91%EF%BC%9F"><span class="toc-number">6.0.8.3.</span> <span class="toc-text">3、搜索一条边还是搜索整棵树？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%EF%BC%9A"><span class="toc-number">6.0.9.</span> <span class="toc-text">12、路径之和：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E4%BB%8E%E5%90%8E%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E4%B8%AD%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">6.0.10.</span> <span class="toc-text">13、从后序和中序中构造二叉树：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.0.11.</span> <span class="toc-text">14、最大二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88-%EF%BC%89"><span class="toc-number">6.0.12.</span> <span class="toc-text">15、验证二叉搜索树（!）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%9A"><span class="toc-number">6.0.13.</span> <span class="toc-text">16、最近公共祖先：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%EF%BC%9A"><span class="toc-number">6.0.14.</span> <span class="toc-text">17、二叉搜索树的修改：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%EF%BC%9A"><span class="toc-number">6.0.14.1.</span> <span class="toc-text">1、二叉树的插入：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88-%EF%BC%89%EF%BC%9A"><span class="toc-number">6.0.14.2.</span> <span class="toc-text">2、二叉树的删除（!）：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B91%EF%BC%9A"><span class="toc-number">6.0.14.2.1.</span> <span class="toc-text">删除节点1：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B92%EF%BC%9A"><span class="toc-number">6.0.14.2.2.</span> <span class="toc-text">删除节点2：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A"><span class="toc-number">6.0.14.3.</span> <span class="toc-text">3、修剪二叉树：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8F%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">6.0.15.</span> <span class="toc-text">18、有序数组变二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number">6.0.16.</span> <span class="toc-text">19、二叉搜索树变累加树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">七、前缀树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.</span> <span class="toc-text">1、基本性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">7.2.</span> <span class="toc-text">2、实现 Trie (前缀树)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">7.2.1.</span> <span class="toc-text">1、存储方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">1、数组：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81Map%EF%BC%9A"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">2、Map：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Trie%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">7.2.2.</span> <span class="toc-text">2、Trie的基本操作：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E4%B9%89%E7%B1%BB-Trie"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">1、定义类 Trie</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81%E6%8F%92%E5%85%A5"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">2、插入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E6%89%BE%E5%8D%95%E8%AF%8D"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">3、查找单词</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D"><span class="toc-number">7.2.2.4.</span> <span class="toc-text">4、前缀匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.3.</span> <span class="toc-text">3、添加与搜索单词 - 数据结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-II"><span class="toc-number">7.4.</span> <span class="toc-text">4、单词搜索 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%819-8%E6%97%A5%E6%BB%B4%E6%BB%B4%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E9%A2%98"><span class="toc-number">7.5.</span> <span class="toc-text">5、9.8日滴滴笔试第二题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%B8%80%EF%BC%9A%E6%9A%B4%E5%8A%9B"><span class="toc-number">7.5.1.</span> <span class="toc-text">法一：暴力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%B0%86%E5%89%8D%E5%90%8E%E7%BC%80%E5%AD%98%E5%85%A5Hash"><span class="toc-number">7.5.2.</span> <span class="toc-text">法二：将前后缀存入Hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E4%B8%89%EF%BC%9A%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">7.5.3.</span> <span class="toc-text">法三：前缀树</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/9daba997.html" title="测试"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="测试"/></a><div class="content"><a class="title" href="/posts/9daba997.html" title="测试">测试</a><time datetime="2023-11-08T06:46:37.000Z" title="发表于 2023-11-08 14:46:37">2023-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/4a17b156.html" title="Hello World">Hello World</a><time datetime="2023-11-06T11:26:29.706Z" title="发表于 2023-11-06 19:26:29">2023-11-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Reflux</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>